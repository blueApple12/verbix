<!DOCTYPE html>
<html lang="he">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Verbix Pro</title>
<style>
    body { margin: 0; padding: 0; background: #120804; color: #ffdca8; font-family: sans-serif; text-align: center; overflow: hidden; }
    #menu { padding: 20px; display: flex; flex-direction: column; align-items: center; }
    input { margin: 10px; padding: 12px; width: 85%; border-radius: 8px; border: none; font-size: 16px; background: #2b1407; color: white; }
    button { margin-top: 20px; padding: 15px 40px; font-size: 20px; border-radius: 12px; background: #d69a3c; font-weight: bold; cursor: pointer; border: none; }
    #blackout { position: fixed; inset: 0; background: black; z-index: 9999; display: none; touch-action: none; }
    #searchFrame { position: fixed; inset: 0; width: 100%; height: 100%; border: none; display: none; }
    .status-dot { position: fixed; bottom: 5px; right: 5px; width: 4px; height: 4px; background: #200; border-radius: 50%; z-index: 10000; transition: background 0.2s; }
</style>
</head>
<body>

<div id="menu">
    <h1>VERBIX <span style="font-size: 12px;">WHISPER</span></h1>
    <input id="hfToken" type="password" placeholder="Hugging Face Token (hf_...)">
    <input id="startWord" placeholder="Trigger Start (e.g. 'המילה היא')">
    <input id="endWord" placeholder="Trigger End (e.g. 'בחירה חופשית')">
    <button id="startBtn">Start Session</button>
</div>

<iframe id="searchFrame"></iframe>
<div id="blackout"></div>
<div class="status-dot" id="dot"></div>

<script>
const $ = id => document.getElementById(id);
let STARTS = [], ENDS = [], currentWord = "", HF_TOKEN = "";
let mediaRecorder;
let audioChunks = [];

const vib = (pattern) => { if ("vibrate" in navigator) navigator.vibrate(pattern); };
const setDot = (color) => { $("dot").style.background = color; };

// Swipe Logic & Triple Tap Reset
let touchStartY = 0;
let lastTap = 0;
let tapCount = 0;

$("blackout").addEventListener('touchstart', e => { 
    touchStartY = e.touches[0].clientY; 
    
    // Triple Tap Logic
    const now = Date.now();
    if (now - lastTap < 400) {
        tapCount++;
    } else {
        tapCount = 1;
    }
    lastTap = now;

    if (tapCount === 3) {
        location.reload(); // Quick reset to menu
    }
});

$("blackout").addEventListener('touchend', e => {
    if (touchStartY - e.changedTouches[0].clientY > 100) revealSearch();
});

function revealSearch() {
    if (!currentWord) return vib(50);
    $("blackout").style.display = "none";
    $("searchFrame").style.display = "block";
}

async function queryWhisper(audioBlob) {
    setDot("#f00"); // Red = AI is thinking
    try {
        const response = await fetch(
            "https://api-inference.huggingface.co/models/openai/whisper-large-v3-turbo",
            {
                headers: { Authorization: `Bearer ${HF_TOKEN}`, "Content-Type": "audio/flac" },
                method: "POST",
                body: audioBlob,
            }
        );
        const result = await response.json();
        if (result.text) processText(result.text.toLowerCase());
    } catch (e) { console.error("Whisper Error", e); }
    setDot("#200"); // Back to standby
}

function processText(text) {
    console.log("Whisper Heard:", text);
    for (let p of ENDS) {
        if (text.includes(p)) {
            let parts = text.split(p);
            let segment = parts[parts.length - 2].trim().split(/\s+/);
            updateWord(segment[segment.length - 1]);
        }
    }
    for (let p of STARTS) {
        if (text.includes(p)) {
            let parts = text.split(p);
            let segment = parts[parts.length - 1].trim().split(/\s+/);
            updateWord(segment[0]);
        }
    }
}

function updateWord(word) {
    word = word.replace(/[.,!?]/g, "");
    if (!word || word === currentWord) return;
    currentWord = word;
    // Note: Some sites block iframe loading. Google works best with "igu=1"
    $("searchFrame").src = `https://www.google.com/search?q=${encodeURIComponent(word)}&igu=1`;
    vib([100, 50, 100]); 
}

async function startRecording() {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    
    mediaRecorder.ondataavailable = e => {
        audioChunks.push(e.data);
        if (mediaRecorder.state === "inactive") {
            const blob = new Blob(audioChunks, { type: 'audio/flac' });
            queryWhisper(blob);
            audioChunks = [];
            if(listening) restartRec();
        }
    };

    const restartRec = () => {
        try {
            setDot("#050"); // Tiny green flash = Recording started
            setTimeout(() => setDot("#200"), 200);
            mediaRecorder.start();
            setTimeout(() => { if(mediaRecorder.state === "recording") mediaRecorder.stop(); }, 4000);
        } catch(e) {}
    };
    
    restartRec();
}

let listening = false;
$("startBtn").onclick = async () => {
    HF_TOKEN = $("hfToken").value;
    STARTS = $("startWord").value.split(",").map(s => s.trim().toLowerCase());
    ENDS = $("endWord").value.split(",").map(s => s.trim().toLowerCase());
    
    if(!HF_TOKEN) return alert("Enter HF Token");

    localStorage.setItem("verbix_start", $("startWord").value);
    localStorage.setItem("verbix_end", $("endWord").value);
    localStorage.setItem("verbix_token", HF_TOKEN);

    $("menu").style.display = "none";
    $("blackout").style.display = "block";
    
    listening = true;
    startRecording();
    vib(100);
    try { await document.documentElement.requestFullscreen(); } catch(e) {}
};

$("startWord").value = localStorage.getItem("verbix_start") || "";
$("endWord").value = localStorage.getItem("verbix_end") || "";
$("hfToken").value = localStorage.getItem("verbix_token") || "";
</script>
</body>
</html>
