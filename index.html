<!DOCTYPE html>
<html lang="he">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Verbix</title>

<style>
body {
    margin: 0;
    padding: 0;
    background: radial-gradient(circle, #2b1407, #120804 70%);
    color: #ffdca8;
    font-family: Georgia, serif;
    text-align: center;
}

h1 {
    margin-top: 30px;
    font-size: 38px;
    letter-spacing: 3px;
    text-shadow: 0 0 12px #ffbf66;
}

.panel {
    margin-top: 40px;
}

input {
    margin-top: 12px;
    padding: 10px;
    font-size: 18px;
    width: 80%;
    max-width: 400px;
    border-radius: 8px;
    border: none;
}

button {
    margin-top: 40px;
    padding: 14px 40px;
    font-size: 22px;
    border: none;
    border-radius: 12px;
    background: linear-gradient(180deg, #ffda8b, #d69a3c);
    color: #4a2a0f;
    font-weight: bold;
    cursor: pointer;
}

#blackout {
    position: fixed;
    inset: 0;
    background: black;
    z-index: 9999;
    display: none;
}
</style>
</head>

<body>

<h1>VERBIX</h1>

<div class="panel" id="menu">
    <input id="startWord" placeholder="Start Phrases (comma separated)">
    <input id="endWord" placeholder="End Phrases (comma separated)">
    <button id="startBtn">Start</button>
</div>

<div id="blackout"></div>

<script>
/* ======================
   DOM & Constants
====================== */
const $ = id => document.getElementById(id);

const startInput = $("startWord");
const endInput   = $("endWord");
const menu       = $("menu");
const blackout   = $("blackout");

const REDIRECT_DELAY = 150;

/* ======================
   Persistent config
====================== */
startInput.value = localStorage.getItem("verbix_start") || "";
endInput.value   = localStorage.getItem("verbix_end")   || "";

/* ======================
   Wake Lock
====================== */
let wakeLock = null;

async function enableWakeLock() {
    try {
        if ("wakeLock" in navigator) {
            wakeLock = await navigator.wakeLock.request("screen");
        }
    } catch {}
}

function releaseWakeLock() {
    try { wakeLock?.release(); } catch {}
    wakeLock = null;
}

document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible" && active) {
        enableWakeLock();
    }
});

/* ======================
   Speech Recognition
====================== */
const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition = null;

let active = false;
let fired = false;
let restarting = false;

let START_RE = null;
let END_RE   = null;

const normalize = s =>
    s.replace(/[.,!?״”“]/g, "")
     .replace(/\s+/g, " ")
     .trim();

const escapeReg = s =>
    s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

/*
 Soft boundaries:
 - start or whitespace before
 - whitespace or end after
 Hebrew-safe, STT-safe
*/
const buildRegex = list =>
    list.length
        ? new RegExp(`(^|\\s)(${list.map(escapeReg).join("|")})(?=\\s|$)`, "i")
        : null;

if (SR) {
    recognition = new SR();
    recognition.lang = "he-IL";
    recognition.continuous = true;
    recognition.interimResults = true;

    recognition.onresult = e => {
        if (fired) return;
        const raw = e.results[e.results.length - 1][0].transcript;
        if (raw) processSpeech(raw);
    };

    recognition.onerror = restart;
    recognition.onend   = restart;
}

function startListening() {
    if (!recognition || active) return;
    active = true;
    try { recognition.start(); } catch {}
}

function restart() {
    if (!active || fired || restarting) return;
    restarting = true;
    setTimeout(() => {
        restarting = false;
        try { recognition.start(); } catch {}
    }, 200);
}

/* ======================
   Core Logic (hot path)
====================== */
function processSpeech(rawText) {
    const text = normalize(rawText);

    if (END_RE) {
        const m = text.match(END_RE);
        if (m) {
            const cut = text.slice(0, m.index).trim();
            if (cut) {
                const i = cut.lastIndexOf(" ");
                return finish(i === -1 ? cut : cut.slice(i + 1));
            }
        }
    }

    if (START_RE) {
        const m = text.match(START_RE);
        if (m) {
            const cut = text.slice(m.index + m[0].length).trim();
            if (cut) {
                const i = cut.indexOf(" ");
                return finish(i === -1 ? cut : cut.slice(0, i));
            }
        }
    }
}

function finish(word) {
    fired = true;
    active = false;

    try { recognition.stop(); } catch {}
    releaseWakeLock();

    setTimeout(() => {
        location.replace(
            "https://www.google.com/search?q=" +
            encodeURIComponent(word)
        );
    }, REDIRECT_DELAY);
}

/* ======================
   UI Actions
====================== */
async function goFullscreen() {
    try { await document.documentElement.requestFullscreen(); } catch {}
}

$("startBtn").onclick = async () => {

    const STARTS = startInput.value
        .split(",")
        .map(normalize)
        .filter(Boolean);

    const ENDS = endInput.value
        .split(",")
        .map(normalize)
        .filter(Boolean);

    if (!STARTS.length && !ENDS.length) {
        alert("Please set at least one START or END phrase.");
        return;
    }

    START_RE = buildRegex(STARTS);
    END_RE   = buildRegex(ENDS);

    localStorage.setItem("verbix_start", startInput.value);
    localStorage.setItem("verbix_end",   endInput.value);

    await goFullscreen();
    enableWakeLock();

    menu.style.display = "none";
    blackout.style.display = "block";

    startListening();
};
</script>

</body>
</html>
